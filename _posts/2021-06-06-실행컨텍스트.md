---

layout : single
title : '실행 컨텍스트 '

---



## 실행 컨텍스트





행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리입니다.

✅ 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해서 필요한 환경이라고 할 수 있습니다.



### 스코프체인

* 스코프 : 식별자에 대한 유효 범위
* 스코프 체인 : 스코프를 안에서 부터 바깥으로 검색해 나간다. ㅇ



## 이벤트 위임(Event Delegation)

✅ **이벤트 위임(Event Delegation)** 이란 동적으로 노드를 생성하고 삭제할 때 각 노드에 대해 이벤트를 추가 하지 않고, 상위 노드에서 하위 노드의 이벤트를 제어 하는 방식입니다.





### 1장 정리 

자바스크립트 데이터 타입에는 크게 기본형과 참조형이 있습니다. 

기본적으로 기본형은 불변값이고, 참조형은 가변값입니다. 

* 불변값 : 한번 만든 값을 다른 값으로 바꿀 수 없다. 새로 만드는 동작을 통해 변경된다. 



변수는 변경 가능한 데이터가 담길 수 있는 공간이고, 

식별자는 그 변수의 이름을 말합니다. 



변수를 선언하면, 컴퓨터는 우선 메모리의 빈 공간에 식별자를 저장하고,  그 공간의 앖은 undefined를 할당합니다. 

이후 그 변수에 기본형 데이터를 할당하려고 하면, 별도의 공간에 저자하고, 그 공간의 주소를 변수의 값 영역에 할당합니다. 



참조형 데이터를 할당하고자 하는 경우, 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 확보된 주소를 변수에 연결하고, 다시 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장하고, 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다. 이처럼 할당 과정에서 기본형과 차이가 생긴 이유는 참조형 데이터가 여러 개의 프로퍼티를 모든 그룹이기 때문이다. 그리고 이 차이로 인해 참조형 데이터를 가변값으로 여겨야만 하는 상황이 발생한다. 



* 참조형 데이터는 가변값일 수 있다. 
* 이는 참조형 데이터 자체를 변경하는 것이 아닌, 그 내부의 프로퍼티를 변경할 때만 성립한다. 
* 즉 참조형 데이터의 식별자에 담긴 데이터는 변하지 않은 상태로 그 데이터의 내부 프로퍼티는 변할 수 있기 때문에 가변 값이라고 한다. 





참조형 데이터를 가변값으로 여겨야 하는 상황임에도 이를 불변값으로 사용하는 방버이 없지는 않습니다. 

이 경우, 내부 프로퍼티들을 일일이 복사하면 됩니다. 혹은 라이브러리를 사용하는 방법도 있습니다. 

불변 객체는 최근 자바스크립트 진영에서 가장 우요한 개념이다. 





### 2장

실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.

(자바스크립트의 코드가 실행되고, 변수 객체, 스코프 체인, this 정보 들을 담고있는 곳 )

 

실행 컨텍스트는 전역 공간에서 자동으로 생성되는 전역 컨텍스트와 eval 함수 실행에 의한 컨텍스트 등이 있습니다. 

실행컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, Lexical Environment, ThisBinding의 세 가지 정보를 수집합니다. 

![실행컨텍스트](/Users/hongji/MY_HOME/실행컨텍스트.png)

실행 컨텍스트를 생성할 때는 VariableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만,

LexicalEnvironemnt는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면, VariableEnvironment는 초기 상태를 유지합니다. 



실행 컨텍스트를 생성할 때, Variable Environemt에 정보를 먼저 담은 다음, 이를 그대로 복사해서 Lexical Environment를 만들고 이후에는 주로 Lexical Environment를 활용한다. 



### 3장

* this는 함수를 호출하는 방법에 의해 결정된다. 호출한 객체가 this라고 이해함. 

  * this는 실행 컨텍스트가 생성될 때 결정된다. 

    

명시적 this 바인딩이 없으면 아래의 규칙을 따른다. 

* 전역 공간에서의 this는 전역 객체를 참조한다. 
* 메서드로서호출한 경우 



## 4장

### 콜백함수

파라미터로 함수를 전달받아, 함수의 내부에서 실행하는 함수다. 

즉, 파라미터로 넘겨받은 함수는 일단 받고 때가 되면 나중에 호출하는 것이 콜백함수의 기본 개념이다. 

다른 함수가 실행을 끝낸 뒤 실행되는 함수다. 

다른 코드의 인자로 넘겨주는 함수다. 콜백함수를 넘겨받은 코드는 이 콜백함수를 필요에 따라 적절한 시점에 실행하게된다. 

다른 코드에게 인자로 넘겨줌으로써, 그 제어권도 함께 위임한 함수다.  콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행할 것이다. 



**콜백함수 사용원칙



### 콜백지옥

비동기 프로그래밍 시 발생하는 문제로서 함수의 매개 변수로 넘겨지는 콜백함수가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상이다. 

비동기 처리 로직을 위해 콜백 함수를 연속해서 사용할 때 발생하게 된다. 

콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기  수준이 감당하기 힘들어질정도로 깊어지는 현상이다. 





## 6장

함수를 생성하면 prototype이라는 객체가 생성된다. 

이 prototype 객체는 constructor 라는 속성이 있는데 자신을 만들어 낸 함수를 참조한다. 



new 연산자를 통해, 즉 생성자로부터 만들어진 객체는  생성자로부터 만들어진 객체는, 객체의 속성값으로 "__ proto__" 가 생성되고, 자신을 만들어낸 객체(함수)의 prototype을 가리킨다. 





### 7장

