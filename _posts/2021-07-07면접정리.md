---
layout : single
title : '면접정리'
---



# JavaScript

## 이벤트루프란?

콜백 큐에 할당된 함수들을 순서에 맞춰서 콜 스택에 할당해주는 역할이다.

콜 스택에서 현재 실행중인 task가 있는지 검사하고, 콜백 큐에도 task가 있는지 반복적으로 검사한다.

만약 콜 스택이 비워져있다면 콜백 큐 내의 task를 콜스택으로 할당시킨다.



## 호이스팅

>  변수 정보를 수집하는 과정

함수와, 변수는 코드를 실행하기 전에 실행 컨텍스트를 만들기 위해서, 메모리에 저장되며, 이를 호이스팅 이라고 한다.

Javascript 엔진 컴파일 과정에서 호이스팅 발생

`var`로 선언된 함수는 undefined로 초기화 된 상태로 저장.

const, let은 초기화 되지 않고 저장된다.



### 호이스팅의 대상

var 변수 선언과, 함수선언문에서만 호이스팅이 일어납니다.



## 실행컨텍스트

> 코드가 실행되기 위한 필요한 환경정보를 모아놓은 객체다. 이를 콜 스택에 쌓아서 실행 순서를 보장한다.

`변수 객체`,`스코프 체인`, `this 프로퍼티` 속성을 가지고 있다.

자바스크립트 엔진은 해당 프로그램을 실행하면, 모든 실행 가능한 코드를 평가해서 실행 문맥을 만든다. 각각의 실행 가능한 코드 별로 실행 문맥이 만들어 진다.

### 실행컨텍스트 구조

- Variable Environment : 초기의 정보를 담고 있음.
- lexical Environment : 이후 변화 추적, scope chain 형성
- thisBinding



### 동작 예시

자바스크립트 엔진은 프로그램이 실행되면, 전역 컨텍스트를 만듭니다.

그리고, 함수가 호출이 될 떄마다 전역 코드 실행을 멈추고 Context를 만든다.

Context가 생성될 때, 변수 객체, 스코프 체인, this가 생성이 된다.

Context 생성 후 함수가 실행되는데, 사용되는 변수 객체 안에서 값을 찾고 없으면 스코프체인을 따라 올라가서 찾는다.

함수 실행이 끝나면 해당 컨텍스트는 클로저를 제외하고 삭제된다. 페이지가 종료되면 전역 컨텍스트가 삭제된다.



## 클로저

> 내부 함수에서, 상위 스코프 지역 변수를 사용하고 있을 때, 내부 함수가 종료된 이후에도 변수가 해제되지 못하는 현상이다.

### 클로저를 사용하는 이유?

변수 은닉화, 콜백함수 내부에서 외부 데이터를 사용하고자 할 때



## 1급객체

자바스크립트에서 함수는 1급 객체다.

### 1급객체의 특징 

* 변수로 담을 수 있다. 
* 파라미터로 전달할 수 있다. 
* 반환값으로 사용할 수 있다.



## ES6 특징

1. Class 지원

2. let & const 문법 추가

3. Arrow Functions

4. Module 기능 추가

5. Promise

6. Spread 연산자

   

## promise, async&await

### async & await의 좋은점?

- 코드가 간결해지고, 가독성이 높아진다.
- 응답 데이터로 들어오는 변수들을 없앨 수 있다.
- try/catch로 에러를 핸들링 할 수 있다.



## 프로토타입

> 자바스크립트는 `프로토타입` 기반 언어다.  (ES6에서 클래스가 추가되었긴하다.) 
>
> 객체 원형인 프로토타입을 이용해서 새로운 객체를 만들어내고, 
>
> 같은 생성자로부터 만들어진 객체들은 모두 프로토타입을 참조한다.



자바스크립트는 함수를 생성하면 prototype이라는 객체가 생성된다.

이 prototype 객체는 constuctor라는 속성이 있는데, 자신을 만들어낸 함수를 참조한다.

생성자로부터 만들어진 객체는, 객체의 속성값으로 __ proto __ 가 생성되고, 

자신을 만들어낸 객체(함수)의 prototype을 가리킨다.



### 프로토타입체인

특정 객체의 메서드나, 프로퍼티에 접근하고자 할 때 

해당 객체에 접근하려고 하는 프로퍼티나 객체가 없다면

**proto** 접근자 프로퍼티(`프로토타입 링크`)를 따라 자신의 부모 역할을 하는 객체를 순차적으로 이동하며 검색한다. 

이를 프로토타입 체인이라 한다.

모든 프로토타입도 객체이기 때문에, 최상위 객체인 Object.prototype까지 도달하게 된다. 



## this

호출한 객체. 함수를 호출하는 방법에 의해 결정된다.

### this바인딩

함수가 호출될 때 this가 동적으로 가리키는 것이 결정되는 것일 바인딩 되었다 함.



### call, apply, bind

함수 호출 방식과 관계없이 this 지정 가능

call은 `단일 인자`가 들어가며, apply는 `배열`이 들어간다.

- call

  * 모든 함수에서 사용할 수 있으며, this를 특정값으로 지정할 수 있다.
  * 매서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 

- apply

  함수 매개 변수를 처리하는 방법을 제외하면, call과 완전히 같음.

  call은 일반적인 함수와 마찬가지로, 매개변수를 직접 받지만, apply는 매개변수를 `배열` 로 받는다.

- bind

  - 함수의 this 값을 영구히 받는다.
  
    



# React

### React의 장점

유저 인터랙션을 처리하기 위한 상태 변화가 상당히 많아졌다. 이를

다양한 라이브러리를 지원하고, react의 가

component 단위 작성을 통한 생산성과 유지 보수 용이

cf) Angular, Vieww

## React 성능 개선

### React key 사용 이유

재조정 과정에서, Key를 사용하면, 변경사항이 있는 부분만 캐치하여 리랜더링 할 수 있기 때문이다.



### Life Cycle

컴포넌트가 DOM 위에 생성되거나, 업데이트 되거나, 사라질 때 호출되는 API다.

- Mounting : React Component 객체가 브라우저에 나타나는 과정
- Updating : Component의 state나 props 변경
- Unmounting : Component Mounting 해제



### Class 컴포넌트와 Functional Component 차이

클래스형 컴포넌트의 경우 state 기능 및 라이프 사이클 기능을 사용할 수 있다.

**함수형 컴포넌트는 render 될 때의 값들을 유지하지만 클래스 컴포넌트는 유지 하지 않는다.**



## Hook

함수형 컴포넌트에서 클래스 컴포넌트에서만 이용이 가능했던 state와 라이플 사이클 메소드를 이용할 수 있도록 리액트의 기능을 함수형 컴포넌트에 연결해준다.

### useState()

함수형 컴포넌트에서 state를 사용할 수 있도록, 함수형 컴포넌트가 여러 번 호출되어도 계속 일정한 데이터를 기억하도록 함.

### useEffect()

라이프 사이클 메소드 처럼 활용 할 수 있음.

어떠한 값의 변화를 감지하면, 실행되어 특정 함수나 작업을 실행

- 빈 배열을 넘기게 되면, effect안의 prop과 state는 초기값을 유지하게 된다.

- 빈 배열 -> 처음 랜더링 될 때 호출 

- 화면에 가장 처음 랜더링 될 떄만 실행되고, 업데이트 할 때는 실행할 필요가 없는 경우

  

### useMemo()

특정 상황에만 특정 동작을 하도록 유도한다.

메모이제이션된 값을 반환한다

### useCallback()

- 메모이제이션된 함수를 반환한다.

  

## Virtual DOM

virtual DOM은 실제 DOM의 변화를 최소화 시켜주는 역할을 합니다.

변화가 일어날 때 바로, 실제 브라우저 DOM을 변화시키는 것이 아닌

Virtual DOM에 한 번 랜더링을 하고,

기존의 DOM과 비교한 다음 변화,  변화가 필요한 곳들만 모아서 한 번만 랜더링 하게 됩니다.

업데이트 할 내용을 모아 한번에 업데이트 되기에 성능 좋음

## 상태관리

props의 한계 : 자신의 바로 위에 있는 컴포넌트로부터 직접 전달 받아야한다.

### Mobx

### Redux

### ContextAPI

context를 이용하면, 단계마다 일일이 props를 넘겨주지 않아도, 컴포넌트 트리 전체에 데이터를 제공할 수 있다.

일반적으로 React 애플리케이션에서 데이터는 위에서 아래로, 즉 부모로부터 자식에게 props를 통해 전달되지만

애플리케이션 안의 여러 컴포넌트들에 전해줘야하는 props의 경우, 이 과정이 번거로울 수 있다.

Context를 이용하면, 트리 단계마다 명시적으로 props를 넘겨주지 않아도, 많은 컴포넌트가 이러한 값을 공유하도록 할 수 있습니다.

```jsx
// 컨텍스트 생성 
const ThemeContext = React.createContext('light')

class App extends React.Component{
	render(){
	
	/*
  	Provider를 이용해 하위 트리에 테마 값을 보내준다. 아무리 깊숙히 있어도, 모든 컴포넌트가 이 값을 읽을 수 있다. 
		아래 예시에는 dark 값을 현재 선택된 테마 값으로 보내고 있다. 
	*/
		return (
		<ThemeConvert.Provider value='dark'>
			<Toolbar theme = 'dark'/>
		</ThemeContext.Povider>
		); 
	}
	function Toolbar(props){
		// 중간에 있는 컴포넌트가 일일이 테마를 넘겨줄 필요가 없다. 
		return (
		<div>
			<ThemeButton/>
		</div>
		); 
	}
	class ThemeButton extends React.Component{
	// 현재 선택된 테마 값을 읽기 위해 contextType을 지정한다. 
	// React는 가장 자까이 있는 테마 Provider를 찾아 그 값을 사용한다. 
		render(){
			return <Button theme={this.context}/>; 
		}
	}
}
```

------

# Network

## HTTP

즉, 하이퍼텍스트를 전송하는 프로토콜로, 웹 브라우저와 웹 서버 사이의 통신 규칙입니다.

### HTTP 메시지

- Request Line

- Header

- 공백 라인

- 메시지 바디  (HTTP 문서, 이미지, 영상 등 byte로 표현할 수 있는 모든 데이터 전송)

  

### HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0

HTTP 1.0은 connection 하나 당, response를 하나만 처리 가능한 반면, HTTP 1.1은 커넥션을 재사용 할 수 있다. (pipelining)

HTTP 1.1은 기본적으로 연결당 하나의 요청과 응답을 처리하기 때문에 동시전송 문제와 다수의 리소스를 처리하기에 속도와 성능이슈를 가지고 있습니다.

HTTP 2.0에서 다수개의 요청을 할 수 있게함.

### Status Code

- 100 : 정보 응답 (요청을 받았고, 작업을 진행중이다.)

- 200: 성공 응답 (이 작업을 성공적으로 이해했으며, 받아들여졌다.)

- 300 : 리다이렉션 응답 (이 요청을 완료하기 위해 리다이렉션 이루어져야 한다.)

- 400: 클라이언트 에러 응답 (올바르지 않은 요청)
  - 403 : Forbidden 금지된 요청을 허가하지 않는 상태
  - 404 : Not Found 요청한 페이지를 찾을 수 없는 상태
  
- 500: 서버 에러 응답 (올바른 요청에 대해 서버가 응답할 수 없음)

  

## 세션, 쿠키

### 사용 이유

클라이언트의 로그인 정보나, 브라우저에서 입력한 값들은 페이지를 이동할 때마다 초기화 된다.

이러한 문제점을 해결하기 위해 `쿠키` , `세션`, `웹 스토리지` 를 사용한다. 

> HTTP 프로토콜의 특징
>
> 1. 비연결 지향 (Connectionless) : 클라이언트가 Request를 보내고, 서버가 Response를 보내면 접속 종료~~
> 2. 무상태 (Stateless) : 통신이 끝나면 상태 정보를 유지하지 않음. 



# 쿠키

- **클라이언트의 로컬에 저장** 되는 만료 기한이 있는 key, value 형태의 작은 데이터 파일이다. (4KB)
- 하나의 도메인 당 20개의 값만 가질 수 있고, 클라이언트에는 300개 까지 저장 가능.
- 사용자가 따로 요청하지 않아도, 브라우저가 요청시 Request Header를 넣어서 자동으로 서버에 전송한다.

### **장점**

- 대부분의 브라우저가 지원한다.

### **단점**

- 자동으로 요청에 포함되어, 쿠키에 대한 정보를 매 해더에 추가하여 보내기 때문에 트래픽 발생
- 작은 용량 (4KB)
- 암호화 X ⇒ 사용자 정보 도난 위험
  - Httponly 설정 추가하여 클라이언트의 접근은 완전히 차단해서 자바스크립트 코드를 통해 정보를 탈취하는 것을 방지

### **사용 목적**

- 세션관리 : 서버에 저장해야할 로그인, 장바구니, 게임 스코어 등의 정보를 관리
- 사용자 맞춤 : 사용자가 선호하는 옵션이나 테마 셋팅
- 사용자 추적 : 사용자의 행동을 기록하고 분석하는 용도

### **쿠키 사용 예시 : 만료 기한이 있는 저장소**

- 광고 팝업 : 오늘만 보기, 7일 동안 띄우지 않기

### **구성 요소**

- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

### **동작방식**

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답





# **웹스토리지**

- 쿠키의 단점을 보완하기 위해, 즉 서버가 아닌 클라이언트에 데이터를 저장할 수 있도록 HTML5에서 웹스토리지라는 기술 탄생함.
- 용량이 크다 (약 5MB, 브라우저마다 차이 존재)
  - 도메인 별 용량 (모바일 2.5MB, 데스크탑 5MB)
  - 부족 시 IndexedDB 사용 (default : 50MB)
- 웹 스토리지 : 로컬 스토리지, 세션 스토리지
- 웹 스토리지는 key와 value 형태로 이루어짐
- 도메인과 브라우저 별로 저장되며, 값은 반드시 문자열로 저장된다.
- HTML5를 지원하지 않는 브라우저의 경우 사용 불가

### **로컬스토리지**

- 로컬에 도메인 별로 지속되는 storage

- 클라이언트에 대한 정보를 브라우저 자체에 **영구적**으로 저장한다.

- 도메인이 다른 경우 로컬 스토리지에 접근할 수 없다.

  - ex) [naver.com](http://naver.com/) , [google.com](http://google.com/)

    ex) 자동 로그인

**세션스토리지**

- 각 세션마다 데이터가 개별적으로 저장되며, 세션 종료 시 (브라우저 닫을 경우) 자동으로 제거되며 같은 도메인이라도 세션이 다르면 데이터에 접근할 수 없다.

  ex) 탭(페이지)가 켜져있는 동안 남아있는 데이터

에디터 임시저장, 비로그인 장바구니, 은행 로그인 시스템



## REST API

HTTP 요청을 보낼 때, 어떤 URI에 어떤 메소드를 사용할지에 대한 규칙

- 동사보다는 명사를, 대문자보다는 소문자
- 자료에 따라 단수 명사, 복수 명사 구분

### Restful API

REST 원칙을 잘 지킨 서비스 디자인.

​	ex) CRUD 기능을 모두 POST로 처리한다면 Restful 하지 못함



## GET, POST 차이

GET은 가져오는 것이고 POST는 수행하는 목적 

- GET은 Idempotent  : 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 한다. 
  - GET 조회 목적 (데이터를 가져와서 보여주거나 하는 용도)
- POST는 Non-idempotent하게 설계 : 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있다. 
  - POST 서버의 값이나 상태를 바꾼다. (디비 저장, 수정)



GET 방식은 서버로부터 정보를 `조회`하기 위해 설계되었다.

요청은 전송할 때 필요한 데이터를 Body에 담지 않고, `쿼리스트링`을 통해 전송하기 때문에 전송하는 길이에 제한이 있다



POST 방식은 리소스를 생성/변경하기 위해 설계되었다. 

전송해야할 데이터를 HTTP 메시지에 `바디`에 담아서 전송한다.

HTTP의 메시지의 Body는 길이의 제한 없이 데이터를 전송할 수 있기 때문에 대용량 데이터를 전송할 수 있다.



### URL을 치면 일어나는 일

1,2) URL 주소를 입력한다. https://naver.com

1. 도메인 네임 부분을 DNS 서버에서 검색한다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 `IP 주소`를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.

5, 6) HTTP 프로토콜을 사용해서 웹 페이의 `URL 정보`와 `IP 주소`를 담은 **`HTTP 요청 메시지`를 `생성`**한다.

이렇게 생성된 HTTP 요청 메시지는 **TCP 프로토콜을 사용**하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.

1. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 **웹 페이지 URL 정보**로 **변환**된다.
2. **`웹 서버`**는 도착한 `웹 페이지 URL 정보`에 해당하는 데이터를 검색한다.

9, 10) 검색된 `웹 페이지 데이터`는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성한다.

이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.

1. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용해서 `웹 페이지 데이터`로 변환된다.

2. 변환된 웹 페이지 데이터는 `웹 브라우저`에 의해 `출력`되어 사용자가 볼 수 있게 된다.

   

## OSI 7계층

- 전송계층 : 목적지에 신뢰할 수 있는 데이터를 전달 (오류를 점검하고, 목적지가 어떤 애플리케이션인지 식별한다.)
- 세션계층 : 응용프로그램간의 연결을 설정하고, 유지하는 역할
- 연결이 안정적으로 유지됟로ㅗㄱ 관리
- 표현계층 : 암호화, 데이터 압축 기능 서로 잘 통신할 수 있도록 필터하고 변환하는 역할
- **표현 방식이 다른 애플리케이션이나 시스템 간의 통신**을 돕기 위해 **하나의 통일된 구문 형식으로 변환**시키는 기능을 수행한다.
- 응용계층 : 사용자가 제공한 명령이나 정보를 하위 계층으로 전달하는 역할
- 네트워크 소프트웨어의 UI 부분이나 사용자 입출력 부분을 정의하는 역할을 한다.



# CS

## 자료구조

### Array vs LinkedList

- Array
  - 탐색 : O(1)  (인덱스만 알고 있다면, 해당 원소 바로 접근 가능)
  - 삽입/삭제 : O(n) (뒤의 원소들을 옮겨주어야함)
- LinkedList : 자료의 주소 값으로 연결된 구조
  - 탐색 : O(n) 원하는 값을 찾기 위해 처음부터 노드를 순회해야 한다.
  - 삽입/추가 : O(1) (맨 앞), 중간 O(n)

### Tree

계층화 된 자료를 표현하는 자료구조. root 노드를 기준으로 각 노드들이 부모, 자식 간의 관계를 갖는 그래프다.

- 조회 : O(n) 순서가 정해져 있지 않음.
- 추가 : O(n) 뒤까지 가야함

### 이진탐색트리

왼쪽 subtree는 자기 자신보다 모두 작고, 오른쪽 subtree는 모두 자기 자신보다 큰 특성을 유지하는 tree 구조 형태다. 이진탐색이 가능해짐.

- O(logn) 높이에 비례, 최악 O(n)

### B tree

모든 leaf node의 level 이 같도록 유지되어,  편향이 되지 않는다.

각 노드에는 key와 각 key에 대응하는 data를 함께 가지고 있다.

### B+ tree

Inner node에는 key 만 저장이 되고, leaf node에 key와 data값이 있음.



## 정렬

### 시간복잡도

알고리즘이 문제를 해결하는데 걸리는 시간.

### 공간복잡도

작성한 프로그램이 얼마나 많은 공간(메모리)을 차지하는가

### 버블정렬

시간복잡도 O(n^2), 공간복잡도는 하나의 배열만 사용하기에 O(n)

### 퀵정렬

divede and concure 방식으로, pivot을 정한 뒤, 왼쪽에는 Pivot보다 작은 값을, 오른쪽에는 pivot보다 큰 값을 배치하고 계속 분할하여 정렬하는 알고리즘이다.

최악의 경우에는 O(n²)의 비교를 수행하지만 일반적으로 O(nlogn)의 시간복잡도를 가진다.

### 병합정렬

퀵정렬과 다르게, pivot 값이 없다. 항상 반으로 나눈다. 최악의 상황에도 , O(nlogn) 보장



## 운영체제

### 프로세스 vs 스레드

프로세스. 프로그램이 실행되서 돌아가고 있는 상태

스레드는 프로세스 내에서 실행되는 여러 흐름의 단위



### 가상메모리

1. 메모리에 확장성을 부여해줍니다.
2. 메모리 할당과 관리에 효율적입니다.
3. 메모리 보호 기능을 제공한다.

각각의 프로세스는 별도의 메모리 공간을 점유하고, 다른 프로세스의 메모리 공간을 참조할 수 없습니다.



## OOP

객체 지향 프로그래밍. 프로그래밍에서 데이터를 추상화 시켜 `데이터`와 `행위`를 가진 `객체`를 만들고, 

그 객체들 간의 유기적인 상호 작용을 통해 로직을 구성하는 프로그래밍 방법



### 객체

데이터와 기능이 클래스로 캡슐화 된 컴퓨터 자원의 묶음



### 클래스

반복되는 불필요한 소스코드를 최소화하면서, 프로그래밍 상에서 쉽게 표현할 수 있도록 하는 프로그래밍 기법

- 클래스의 멤버 : 클래스 내부에 포함되는 변수

- 클래스의 함수(메소드) : 클래스 내부에 포함되는 함수

  

### 인스턴스

클래스로 정의 된 객체를 프로그램 상에서 이용할 수 있게 만든 변수



### 추상화 (abstract)

해결해야할 문제를 단순화



### 캡슐화

외부에서 특정 속성, 메소드를 사용할 수 없도록 숨겨놓기 .



### 상속

기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것이다.

장점

- 코드를 재사용함으로써, 중복을 줄인다.

- 유연성 및 확장성 증가

- 개발 시간 단축

  

### composition 조합

[상속보다는 조합(Composition)을 사용하자.](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

기존 클래스가 새로운 클래스의 구성 요소로 쓰인다.

새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조한다.



### 다형성

하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것.

- 오버로딩 : 같은 이름이지만 다른 동작 방법



### 오버로딩 = 파라미터만 다른 것.

리턴타입, 함수명은 같은데 **파라미터가 다른 것**

### 오버라이딩 = 재정의

자식 클레스에서 다시 만들어서 사용



------

# Project

## 역할

드로잉툴, 음성, rest api

## 아키텍처 구조

서버 3개 사용

**nginx**는 드로잉 서비스 및 로비 페이지

spring 방 정보 같은 DB에

node.js

### 요즘 관심있는 분야

### 내가 한 역할

드로잉툴, 음성, rest api

Agora RTC SDK 사용

### React 선택이유

기술스택을 알아볼 시간과, 충분한 경험이 있지 못했다.

우선, 기간 내에 완성이 목표였기 때문에

다 시간이 없었따.... ;;;

참고할만한 자료가 많은 한글 라이브러리 공식 문서가 잘되어있어서 선택

## 어려웠던 점

### React 사용 부분  = 확장성

재사용 부분

`기술 스택 선택`이 자유롭다.

컴포넌트 단위 개발하기에 적합하다.

다양한 라이브러리, 프레임워크와 함께 사용할 수 있다.

가볍게 뷰 랜더링만 하기에도 좋다.

virtual DOM 기반의 효율적인 랜더링 연산



### 베지어 곡선, 네트워크 방법 수정 , 서버 분리



### TypeScript 사용, 장점

정적 타입으로 안정성 보장



### Socket.io

WebSocket, [Socket.io](http://socket.io) 2가지를 생각해볼 수 있음.

WebSocket은 일부 브라우저에서 대응하지 못하는 문제가 있었다. 

`Socekt.io` 에는 broadcast 함수가 있다. 하지만, 웹소켓은 없기 때문에 직접 구현해야해서 공수가 많이 들 것이다.



### 진행 순서

1) 서버에서 socket 생성 후 내 컴퓨터에 연결(bind)

2) 수신 대기 상태로 변경 (listen)

3) 클라이언트에서 socket 생성 후 서버에 connect 전송

4) 서버에서 통신 가능한 경우 accept

1. send ↔ recv

6) 종료 closesocket

노드는  통신 괒어이 빠르다 .



### Mobx 왜 고려 안함?

- 레퍼런스 가뭄....?  많이 사용하는거 익혀보려고

객체 지향 느낌이 좀 더 강하다.

Redux 데코레이터

Mobx 는 Redux는 store 개수가제한이 있는데

Mobx store 의 개수 제한이 없어서 로직별로 store를 분리항여 깔끔하게 비즈니스 로직을 작성할 수 있고,

action, connect 관련 일들을 데코레이터로 ㅂ정의

state를 연결해주는 작업들을 데코레터로 변리하게 할 수 있다라는 것을 알게되어쏘



### 베지어곡선 전송 과정

처음에는 webrtc 방식을 사용했다. 각 클라이언트가 직접 그림 데이터를 송수신하는 역할을 하였다. 

각 클라이언트는 p2p 통신으로 서로 그림 데이터를 주고 받게 되었고, 서버는 클라이언트의 연결 성립만을 수행하였다.

프록시를 사용하여 서버간 역할 분리 .

하지만, 실시간으로 많은 양의 그림 데이터를 주고받으면서 성능 저하

웹 소켓 방식으로 그림 데이터를 모두 서버로 전송하고, 서버가 데이터를 모두 보내주는 방식을 사용



### agoraRTC

### node.js

어느 곳에서나 자바스크립트로 프로그래밍이 가능하게 하는 프레임워크다.

프로세스 막 fork 하다가 안만들어져서 leak...?

버튼 함수 카운팅

서버에서 넘겨주면 덜된 버튼 삭제



------

# 브라우저 & HTML

## HTML5

HTML의 웹 표준. HTML이 다양한 애플리케이션 까지 표현, 제공할 수 있게 됨.



### Sementic tag

HTML5에 도입됨. 태그만 보고 내용 유추 가능.



## 브라우저 랜더링 과정

브라우저가 HTML 파일을 요청하고, 서버로부터 HTML 파일을 받습니다.

그 이후, HTML 파서가 HTML을 한 줄 씩 읽어나가며, `DOM Tree`를 구성합니다.

브라우저가 DOM Tree를 만들게 되면, 정의해 놓은 CSS를 병합해서 `CSSOM`을 만듭니다.

그 다음, DOM과 CSSOM을 합쳐서 최종적으로 브라우저에 표시될 것만 선별하여 `Render Tree`를 만듭니다.

이후, 각 요소가 어디에 얼마만큼의 크기로 배치될지 레이아웃을 구성하고,

이후 요소를 묶어 레이어를 만듭니다.

준비한 레이어를 순서대로 브라우저에 표기한다.



## CSR & SSR의 차이점

> CSR은 페이지의 내용을 클라이언트, 즉 브라우저에서 그리고, 
>
> 서버사이드 랜더링은 서버에서 완벽하게 만들어진 HTML 파일을 받아오고, 이를 웹 브라우저에 랜더링 한다.



### CSR

CSR의 경우 HTML 다운로드 받고, JS 파일 받고, 각종 리소스를 다운 받은 후 브라우저에서 랜더링 하기 때문에 초기 로딩 속도는 느리다. 하지만 그 이후에는 서버에 다시 요청할 필요없이 클라이언트 내에서 작업이 이루어지므로 매우 빠름.

### SSR

* 서버에서 View를 랜더링 해오기 때문에 초기 로딩 속도가 빠르다. 

* 또한, SEO에 유리하지만, View 변경 시 서버에 계속 요청을 해야하므로 서버에 부담이 크다.



### 진행과정

### 랜더링 성능 향상 방법

- script 파일 body tag 하단 위치
- script async 속성 부여

------



### 반응형 프로그래밍 ReactiveX

데이터가 변경될 떄마다 관련된 로직을 일일이 호출하는 것이 아니라,

데이터 스트림이 존재하고 이를 구독하는 곳에서 변화에 따라 알아서 처리하겠다는 것.

함수형 프로그래밍

코딩 중 오류의 소지가 있을 수 있는 변수의 사용을 지양하고, 순수함수를 사용해서 프로그래밍 하는 것이다.

스트림. 이런 평면적인 배열 시간의 흐름, 사용자의 동작, 네트워크 요청의 결과 까지 전부 스트림을 만들어서 처리할 수 있다.

이러한 값의 흐름들을 선언해놓을테니까 뭐가 나오면 이걸 하면 된다.

구현하고자하는 소프트웨어

obserable

옵저버블이 발행해서 파이프에서 정제된 값들을 구독자들이 지정된 작업을 수행

